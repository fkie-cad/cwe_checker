<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Cwe_476 (cwe_checker_core.Cwe_checker_core.Cwe_476)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">cwe_checker_core</a> &#x00BB; <a href="../index.html">Cwe_checker_core</a> &#x00BB; Cwe_476</nav><h1>Module <code>Cwe_checker_core.Cwe_476</code></h1><nav class="toc"><ul><li><a href="#how-the-check-works">How the check works</a><ul><li><a href="#parameters-configurable-in-config.json">Parameters configurable in config.json</a></li><li><a href="#symbols-configurable-in-config.json">Symbols configurable in config.json</a></li></ul></li><li><a href="#false-positives">False Positives</a></li><li><a href="#false-negatives">False Negatives</a></li></ul></nav></header><aside><p>This module implements a check for CWE-476: NULL Pointer Dereference.</p><p>Functions like malloc() may return NULL values instead of pointers to indicate failed calls. If one tries to access memory through this return value without checking it for being NULL first, this can crash the program.</p><p>See <a href="https://cwe.mitre.org/data/definitions/476.html">https://cwe.mitre.org/data/definitions/476.html</a> for a detailed description.</p></aside><section><header><h2 id="how-the-check-works"><a href="#how-the-check-works" class="anchor"></a>How the check works</h2><p>Using dataflow analysis we search for an execution path where a memory access using the return value of a symbol happens before the return value is checked through a conditional jump instruction.</p><p>Note that the check relies on Bap-generated stubs to identify return registers of the checked functions. Therefore it only works for functions for which Bap generates these stubs.</p></header><section><header><h3 id="parameters-configurable-in-config.json"><a href="#parameters-configurable-in-config.json" class="anchor"></a>Parameters configurable in config.json</h3><ul><li>strict_call_policy={true, false}: Determines behaviour on call and return instructions. If false, we assume that the callee, resp. the caller on a return instruction, checks all unchecked values still contained in parameter registers. If true, every unchecked value on a call or return instruction gets reported.</li><li>strict_mem_policy={true, false}: Determines behaviour on writing an unchecked return value to a memory region other than the stack. If true, these instances get reported. Depending on the coding style, this can lead to a lot false positives if return values are only checked after writing them to their target destination. If false, these instances do not get reported, which in turn can lead to false negatives.</li><li>max_steps=&lt;num&gt;: Max number of steps for the dataflow fixpoint algorithm.</li></ul></header></section><section><header><h3 id="symbols-configurable-in-config.json"><a href="#symbols-configurable-in-config.json" class="anchor"></a>Symbols configurable in config.json</h3><p>The symbols are the functions whose return values are assumed to be potential NULL pointers.</p></header></section></section><section><header><h2 id="false-positives"><a href="#false-positives" class="anchor"></a>False Positives</h2><ul><li>If strict_mem_policy is set to true, writing a return value to memory other than the stack gets reported even if a NULL pointer check happens right afterwards.</li><li>The check has no knowledge about the actual number of parameters that an extern function call takes. This can lead to false positives if strict_call_policy is set to true.</li></ul></header></section><section><header><h2 id="false-negatives"><a href="#false-negatives" class="anchor"></a>False Negatives</h2><ul><li>We do not check whether an access to a potential NULL pointer happens regardless of a prior check.</li><li>We do not check whether the conditional jump instruction checks specifically for the return value being NULL or something else</li><li>For functions with more than one return value we do not distinguish between the return values.</li><li>If strict_mem_policy is set to false, unchecked return values that are saved somewhere other than the stack may be missed.</li><li>The check has no knowledge about the actual number of parameters that an extern function call takes. This can lead to false negatives, especially if function parameters are passed on the stack.</li></ul></header><dl><dt class="spec value" id="val-name"><a href="#val-name" class="anchor"></a><code><span class="keyword">val</span> name : string</code></dt><dt class="spec value" id="val-version"><a href="#val-version" class="anchor"></a><code><span class="keyword">val</span> version : string</code></dt><dt class="spec value" id="val-check_cwe"><a href="#val-check_cwe" class="anchor"></a><code><span class="keyword">val</span> check_cwe : <span>Bap.Std.program Bap.Std.term</span> <span>&#45;&gt;</span> Bap.Std.project <span>&#45;&gt;</span> <span>Bap.Std.word Bap.Std.Tid.Map.t</span> <span>&#45;&gt;</span> <span><span>string list</span> list</span> <span>&#45;&gt;</span> <span>string list</span> <span>&#45;&gt;</span> unit</code></dt></dl></section></div></body></html>